// Code generated by go-swagger; DO NOT EDIT.

package operations

// This file was generated by the swagger tool.
// Editing this file might prove futile when you re-run the generate command

import (
	"net/http"

	errors "github.com/go-openapi/errors"
	middleware "github.com/go-openapi/runtime/middleware"
	strfmt "github.com/go-openapi/strfmt"
	swag "github.com/go-openapi/swag"

	models "github.com/c360dev/sawmint/models"
)

// PostBatchStatusesHandlerFunc turns a function with the right signature into a post batch statuses handler
type PostBatchStatusesHandlerFunc func(PostBatchStatusesParams) middleware.Responder

// Handle executing the request and returning a response
func (fn PostBatchStatusesHandlerFunc) Handle(params PostBatchStatusesParams) middleware.Responder {
	return fn(params)
}

// PostBatchStatusesHandler interface for that can handle valid post batch statuses params
type PostBatchStatusesHandler interface {
	Handle(PostBatchStatusesParams) middleware.Responder
}

// NewPostBatchStatuses creates a new http.Handler for the post batch statuses operation
func NewPostBatchStatuses(ctx *middleware.Context, handler PostBatchStatusesHandler) *PostBatchStatuses {
	return &PostBatchStatuses{Context: ctx, Handler: handler}
}

/*PostBatchStatuses swagger:route POST /batch_statuses postBatchStatuses

Fetches the committed statuses for a set of batches

Identical to `GET /batch_statuses`, but takes ids of batches as a JSON
formatted POST body rather than a query parameter. This allows for many
more batches to be checked and should be used for more than 15 ids.

Note that because query information is not encoded in the URL, no `link`
will be returned with this query.


*/
type PostBatchStatuses struct {
	Context *middleware.Context
	Handler PostBatchStatusesHandler
}

func (o *PostBatchStatuses) ServeHTTP(rw http.ResponseWriter, r *http.Request) {
	route, rCtx, _ := o.Context.RouteInfo(r)
	if rCtx != nil {
		r = rCtx
	}
	var Params = NewPostBatchStatusesParams()

	if err := o.Context.BindValidRequest(r, route, &Params); err != nil { // bind params
		o.Context.Respond(rw, r, route.Produces, route, err)
		return
	}

	res := o.Handler.Handle(Params) // actually handle the request

	o.Context.Respond(rw, r, route.Produces, route, res)

}

// PostBatchStatusesOKBody post batch statuses o k body
// swagger:model PostBatchStatusesOKBody
type PostBatchStatusesOKBody struct {

	// data
	Data models.BatchStatuses `json:"data,omitempty"`
}

// Validate validates this post batch statuses o k body
func (o *PostBatchStatusesOKBody) Validate(formats strfmt.Registry) error {
	var res []error

	if err := o.validateData(formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (o *PostBatchStatusesOKBody) validateData(formats strfmt.Registry) error {

	if swag.IsZero(o.Data) { // not required
		return nil
	}

	if err := o.Data.Validate(formats); err != nil {
		if ve, ok := err.(*errors.Validation); ok {
			return ve.ValidateName("postBatchStatusesOK" + "." + "data")
		}
		return err
	}

	return nil
}

// MarshalBinary interface implementation
func (o *PostBatchStatusesOKBody) MarshalBinary() ([]byte, error) {
	if o == nil {
		return nil, nil
	}
	return swag.WriteJSON(o)
}

// UnmarshalBinary interface implementation
func (o *PostBatchStatusesOKBody) UnmarshalBinary(b []byte) error {
	var res PostBatchStatusesOKBody
	if err := swag.ReadJSON(b, &res); err != nil {
		return err
	}
	*o = res
	return nil
}
