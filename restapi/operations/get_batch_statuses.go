// Code generated by go-swagger; DO NOT EDIT.

package operations

// This file was generated by the swagger tool.
// Editing this file might prove futile when you re-run the generate command

import (
	"net/http"

	errors "github.com/go-openapi/errors"
	middleware "github.com/go-openapi/runtime/middleware"
	strfmt "github.com/go-openapi/strfmt"
	swag "github.com/go-openapi/swag"

	models "github.com/faddat/sawmint/models"
)

// GetBatchStatusesHandlerFunc turns a function with the right signature into a get batch statuses handler
type GetBatchStatusesHandlerFunc func(GetBatchStatusesParams) middleware.Responder

// Handle executing the request and returning a response
func (fn GetBatchStatusesHandlerFunc) Handle(params GetBatchStatusesParams) middleware.Responder {
	return fn(params)
}

// GetBatchStatusesHandler interface for that can handle valid get batch statuses params
type GetBatchStatusesHandler interface {
	Handle(GetBatchStatusesParams) middleware.Responder
}

// NewGetBatchStatuses creates a new http.Handler for the get batch statuses operation
func NewGetBatchStatuses(ctx *middleware.Context, handler GetBatchStatusesHandler) *GetBatchStatuses {
	return &GetBatchStatuses{Context: ctx, Handler: handler}
}

/*GetBatchStatuses swagger:route GET /batch_statuses getBatchStatuses

Fetches the committed statuses for a set of batches

Fetches an array of objects with a status and id for each batch
requested. There are four possible statuses with string values
`'COMMITTED'`, `'INVALID'`, `'PENDING'`, and `'UNKNOWN'`.

The batch(es) you want to check can be specified using the `id` filter
parameter. If a `wait` time is specified in the URL, the API will wait
to respond until all batches are committed, or the time in seconds has
elapsed. If the value of `wait` is not set (i.e., `?wait&id=...`), or
it is set to any non-integer value other than `false`, the wait time
will be just under the API's specified timeout (usually 300).

Note that because this route does not return full resources, the
response will not be paginated, and there will be no `head` or
`paging` properties.


*/
type GetBatchStatuses struct {
	Context *middleware.Context
	Handler GetBatchStatusesHandler
}

func (o *GetBatchStatuses) ServeHTTP(rw http.ResponseWriter, r *http.Request) {
	route, rCtx, _ := o.Context.RouteInfo(r)
	if rCtx != nil {
		r = rCtx
	}
	var Params = NewGetBatchStatusesParams()

	if err := o.Context.BindValidRequest(r, route, &Params); err != nil { // bind params
		o.Context.Respond(rw, r, route.Produces, route, err)
		return
	}

	res := o.Handler.Handle(Params) // actually handle the request

	o.Context.Respond(rw, r, route.Produces, route, res)

}

// GetBatchStatusesOKBody get batch statuses o k body
// swagger:model GetBatchStatusesOKBody
type GetBatchStatusesOKBody struct {

	// data
	Data models.BatchStatuses `json:"data,omitempty"`

	// link
	Link models.Link `json:"link,omitempty"`
}

// Validate validates this get batch statuses o k body
func (o *GetBatchStatusesOKBody) Validate(formats strfmt.Registry) error {
	var res []error

	if err := o.validateData(formats); err != nil {
		res = append(res, err)
	}

	if err := o.validateLink(formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (o *GetBatchStatusesOKBody) validateData(formats strfmt.Registry) error {

	if swag.IsZero(o.Data) { // not required
		return nil
	}

	if err := o.Data.Validate(formats); err != nil {
		if ve, ok := err.(*errors.Validation); ok {
			return ve.ValidateName("getBatchStatusesOK" + "." + "data")
		}
		return err
	}

	return nil
}

func (o *GetBatchStatusesOKBody) validateLink(formats strfmt.Registry) error {

	if swag.IsZero(o.Link) { // not required
		return nil
	}

	if err := o.Link.Validate(formats); err != nil {
		if ve, ok := err.(*errors.Validation); ok {
			return ve.ValidateName("getBatchStatusesOK" + "." + "link")
		}
		return err
	}

	return nil
}

// MarshalBinary interface implementation
func (o *GetBatchStatusesOKBody) MarshalBinary() ([]byte, error) {
	if o == nil {
		return nil, nil
	}
	return swag.WriteJSON(o)
}

// UnmarshalBinary interface implementation
func (o *GetBatchStatusesOKBody) UnmarshalBinary(b []byte) error {
	var res GetBatchStatusesOKBody
	if err := swag.ReadJSON(b, &res); err != nil {
		return err
	}
	*o = res
	return nil
}
